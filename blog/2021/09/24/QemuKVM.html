<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <link rel="icon" type="image/png" href="/favicon.png">
    
      <title>Installing and configuring QEMU with KVM in Arch Linux - Martín's blog</title>
    

    <!--
      Included files have their own css, js files and will not be 
      appear here. 
    -->

    <!-- ====== CSS Files ====== -->
    <link rel="stylesheet" href="/css/site-top-bar.css">
    <link rel="stylesheet" href="/css/site-footer.css">
    <link rel="stylesheet" href="/css/site-menu.css">
    
    
    <link rel="stylesheet" href="/css/syntax.css">
    
    <link rel="stylesheet" href="/css/blog/post.css">
    
    
    <!-- ====== END CSS Files ====== -->

    <!-- ====== JS Files ====== -->
    <script type="text/javascript" src="/js/common.js"></script>
    <script type="text/javascript" src="/js/site-menu.js"></script>
    <script type="text/javascript" src="/js/site-top-bar.js"></script>

    
    
    <!-- ====== END JS Files ====== -->

    <!-- ====== Font Awesome ====== -->
    <script src="https://kit.fontawesome.com/0cfe53209a.js" crossorigin="anonymous">
    </script>
    <!-- ====== END Font Awesome ====== -->

    

    <!-- ====== SEO ====== -->
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Installing and configuring QEMU with KVM in Arch Linux | Martín’s blog</title>
<meta name="generator" content="Jekyll v4.2.1">
<meta property="og:title" content="Installing and configuring QEMU with KVM in Arch Linux">
<meta name="author" content="Martín E. Zahnd">
<meta property="og:locale" content="en_US">
<meta name="description" content="This is a brief tutorial for running VMs using QEMU/KVM in the same machine they’re created (localhost), using ArchLinux as host OS. It is heavily influenced by the ArchWiki posts on the subject (see Sources and useful links).">
<meta property="og:description" content="This is a brief tutorial for running VMs using QEMU/KVM in the same machine they’re created (localhost), using ArchLinux as host OS. It is heavily influenced by the ArchWiki posts on the subject (see Sources and useful links).">
<link rel="canonical" href="https://mzahnd.github.io/blog/2021/09/24/QemuKVM.html">
<meta property="og:url" content="https://mzahnd.github.io/blog/2021/09/24/QemuKVM.html">
<meta property="og:site_name" content="Martín’s blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-09-24T19:42:00-03:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Installing and configuring QEMU with KVM in Arch Linux">
<meta name="google-site-verification" content="CT3cmVw_OhpKeDjTSMDoO9zCxnArTWa8PcyuM0xfozs">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Martín E. Zahnd"},"dateModified":"2021-09-24T19:42:00-03:00","datePublished":"2021-09-24T19:42:00-03:00","description":"This is a brief tutorial for running VMs using QEMU/KVM in the same machine they’re created (localhost), using ArchLinux as host OS. It is heavily influenced by the ArchWiki posts on the subject (see Sources and useful links).","headline":"Installing and configuring QEMU with KVM in Arch Linux","mainEntityOfPage":{"@type":"WebPage","@id":"https://mzahnd.github.io/blog/2021/09/24/QemuKVM.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://mzahnd.github.io/assets/logo.png"},"name":"Martín E. Zahnd"},"url":"https://mzahnd.github.io/blog/2021/09/24/QemuKVM.html"}</script>
<!-- End Jekyll SEO tag -->

    <!-- ====== End SEO ====== -->
  </head>
  <body>
    



<div class="site-menu--container" id="site-main-menu">

  <button class="btn" id="btn-site-main-menu-close">
    <i class="fas fa-times"></i>
  </button>
  <div class="menu-content">
    <img src="/assets/logo.png" class="logo" alt="Logo" loading="lazy">
    <ul class="menu-list">
      
      <li>
        <a href="/" class="btn btn-link">Home</a>
      </li>
      
      <li>
        <a href="/blog" class="btn btn-link">Blog</a>
      </li>
      
      <li>
        <a href="/notes" class="btn btn-link">Notes</a>
      </li>
      
    </ul>

    <ul class="menu-info-list">
      
      <li>
        <a href="/about.html" class="btn btn-link">About</a>
      </li>
      
      <li>
        <a href="/contact.html" class="btn btn-link">Contact</a>
      </li>
      
    </ul>

    <div class="accessibility-opts">
      <p>Current font size: 
        <span id="accessibility-font-size-label">0 pt</span>
      </p>
      <ul>
        <li>
          <button class="btn" id="accessibility-zoom-reset">
            <i class="fas fa-undo-alt"></i>
          </button>
        </li>
        <li>
          <button class="btn" id="accessibility-zoom-m">
            <i class="fas fa-minus"></i>
          </button>
        </li>
        <li>
          <button class="btn" id="accessibility-zoom-p">
            <i class="fas fa-plus"></i>
          </button>
        </li>
      </ul>
    </div>
  </div>
</div>


    <div id="container-page">
        


<header class="site-top-bar">
  <div class="top-bar--container" id="top-bar">
    <button class="top-bar-btn" id="btn-toggle-menu">
      <i class="fas fa-bars"></i>
    </button>
    <div class="top-bar-separator"></div>
    <div class="top-bar-logo">
        <a href="/">
          <p>Martín's blog</p>
          <img class="logo" src="/assets/logo.png" alt="Logo" loading="eager">
        </a>
      </div>
    <div class="top-bar-separator"></div>
  </div>
</header>

        
          <div class="page-content">
        
            




<div class="post-content">
    




<header>
  <h1 id="post-title">Installing and configuring QEMU with KVM in Arch Linux</h1>
  <p id="post-author">Written by Martín E. Zahnd</p>

  <p id="post-date">Published: 2021-09-24 19:42</p>
  
  
  <p id="post-tags">Tags: 
      
          qemu, 
      
          kvm, 
      
          vm
      
  </p>
  
  <br>

  <div class="post-excerpt">
      <p>This is a brief tutorial for running VMs using QEMU/KVM in the same machine they’re created 
(localhost), using ArchLinux as host OS. It is heavily influenced by the ArchWiki posts on the
subject (see <a href="#sources">Sources and useful links</a>).</p>


  </div>
</header>

<ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#hardware-support">Hardware support</a></li>
<li class="toc-entry toc-h1"><a href="#kernel-modules">Kernel modules</a></li>
<li class="toc-entry toc-h1"><a href="#packages-to-install">Packages to install</a></li>
<li class="toc-entry toc-h1">
<a href="#libvirt-configuration">libvirt configuration</a>
<ul>
<li class="toc-entry toc-h2"><a href="#setting-up-authentication">Setting up authentication</a></li>
<li class="toc-entry toc-h2"><a href="#services">Services</a></li>
<li class="toc-entry toc-h2"><a href="#test">Test</a></li>
</ul>
</li>
<li class="toc-entry toc-h1">
<a href="#creating-and-managing-virtual-machines">Creating and managing virtual machines</a>
<ul>
<li class="toc-entry toc-h2">
<a href="#disk-image-creation-using-the-command-line">Disk image creation using the command line</a>
<ul>
<li class="toc-entry toc-h3"><a href="#fixed-size-disk-image">Fixed size disk image</a></li>
<li class="toc-entry toc-h3"><a href="#dynamically-allocated-disk-image">Dynamically allocated disk image</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#setting-up-the-virtual-machine-using-virtual-machine-manager">Setting up the virtual machine using Virtual Machine Manager</a>
<ul>
<li class="toc-entry toc-h3"><a href="#establishing-a-connection">Establishing a connection</a></li>
<li class="toc-entry toc-h3"><a href="#configuring-the-disk-image">Configuring the disk image</a></li>
<li class="toc-entry toc-h3">
<a href="#creating-a-virtual-machine">Creating a virtual machine</a>
<ul>
<li class="toc-entry toc-h4"><a href="#vm-creation-disk-image-vmm">Disk image</a></li>
<li class="toc-entry toc-h4"><a href="#final-step-in-the-wizard">Final step in the wizard</a></li>
<li class="toc-entry toc-h4"><a href="#finishing-touches-before-running-for-the-first-time">Finishing touches before running for the first time</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#network-connection">Network connection</a>
<ul>
<li class="toc-entry toc-h3"><a href="#start-virt-net-default">Starting virtual network: ‘default’</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#sources">Sources and useful links</a></li>
</ul>






<article>
  <div class="post-content">
    

<h1 id="hardware-support">Hardware support</h1>

<p>In the first place we have to verify that our hardware has virtualization support.

</p>
<p>To this, either run</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span><span class="nv">LC_ALL</span><span class="o">=</span>C lscpu | <span class="nb">grep </span>Virtualization
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>or</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span><span class="nb">grep</span> <span class="nt">-E</span> <span class="nt">--color</span><span class="o">=</span>auto <span class="s1">'vmx|svm|0xc0f'</span> /proc/cpuinfo
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>If the previous command echoes nothing in the terminal, there’s no virtualization support included
in your current hardware.</p>

<h1 id="kernel-modules">Kernel modules</h1>

<p>After that, one has to verify that the needed modules are compiled with the current kernel and
loaded at runtime.</p>

<p>Running</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span>zgrep CONFIG_KVM /proc/config.gz
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>should print a list with <strong>all</strong> options set as <code>y</code> or <code>m</code>.</p>

<p>The modules that have to be loaded are <code>kvm</code> and, for Intel CPUs, <code>kvm_intel</code> or <code>kvm_amd</code> for AMD
ones.</p>

<p>Run</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span>lsmod | <span class="nb">grep </span>kvm
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>to verify that both modules are loaded.</p>

<h1 id="packages-to-install">Packages to install</h1>

<p>We’ll need a bunch of packages in our system, some of which are actually optional but recommended
to make our work a little easier.</p>

<ul>
  <li>
<strong>qemu</strong> (or <strong>qemu-headless</strong> for the version without GUI).</li>
  <li><strong>libvirt</strong></li>
  <li>
<strong>samba</strong>: SMB/CIFS server support.</li>
  <li>
<a href="https://virt-manager.org/" title="virt-manager"><strong>virt-manager</strong></a>: Graphically manage KVM, Xen, or LXC via libvirt.</li>
  <li>
<strong>virt-viewer</strong>: Simple remote display client. (part of virt-manager)</li>
  <li>
<strong>bridge-utils</strong>: For bridged networking.</li>
  <li>
<strong>iptables-nft</strong>, <strong>dnsmasq</strong>: For the default NAT/DHCP networking.</li>
  <li>
<strong>openbsd-netcat</strong>: For remote management over SSH.</li>
  <li>
<strong>edk2-ovmf</strong>: UEFI support for guests.</li>
</ul>

<blockquote>
  <p>Note:
If you are using <strong>firewalld</strong>, as of libvirt 5.1.0 and firewalld 0.7.0 you no longer need
to change the firewall backend to <strong>iptables</strong>. libvirt now installs a zone called ‘libvirt’ in
firewalld and manages its required network rules there. Firewall and network filtering in libvirt.</p>
</blockquote>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]#</span><span class="w"> </span>pacman <span class="nt">-S</span> qemu libvirt samba virt-manager virt-viewer bridge-utils iptables-nft dnsmasq openbsd-netcat edk2-ovmf
</pre></td>
</tr></tbody></table></code></pre></div></div>

<h1 id="libvirt-configuration">libvirt configuration</h1>

<h2 id="setting-up-authentication">Setting up authentication</h2>

<p>Add your user to <code>libvirt</code> group.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]#</span><span class="w"> </span>usermod <span class="nt">-a</span> <span class="nt">-G</span> libvirt &lt;username&gt;
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Then modify the <code>/etc/libvirt/libvirtd.conf</code> file and look for <code>unix_sock_group</code>and <code>unix_sock_ro_perms</code> options:</p>

<pre><code># Set the UNIX domain socket group ownership. This can be used to
# allow a 'trusted' set of users access to management capabilities
# without becoming root.
#
# This setting is not required or honoured if using systemd socket
# activation.
#
# This is restricted to 'root' by default.
unix_sock_group = "libvirt"

# Set the UNIX socket permissions for the R/O socket. This is used
# for monitoring VM status only
#
# This setting is not required or honoured if using systemd socket
# activation.
#
# Default allows any user. If setting group ownership, you may want to
# restrict this too.
unix_sock_ro_perms = "0777"
</code></pre>

<blockquote>
  <p><strong>Note:</strong> In the previous block of text, comments were copied from the distributed configuration
file.</p>
</blockquote>

<h2 id="services">Services</h2>

<p>Start <code>libvirtd.service</code> and <code>virtlogd.service</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre><span class="gp">]#</span><span class="w"> </span>systemctl start libvirtd.service
<span class="gp">]#</span><span class="w"> </span>systemctl start virtlogd.service
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>If you want to enable them, <strong>only do so with</strong> <code>libvirtd.service</code>, which also enables
<code>virtlogd.socket</code> and <code>virtlockd.socket</code>, so there’s no need to enable <code>virtlogd.service</code>.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]#</span><span class="w"> </span>systemctl <span class="nb">enable </span>libvirtd.service
</pre></td>
</tr></tbody></table></code></pre></div></div>

<h2 id="test">Test</h2>
<p>To test if libvirt is working properly on a system level, we should run:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span>virsh <span class="nt">-c</span> qemu:///system
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>To do the same for a user-session level:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span>virsh <span class="nt">-c</span> qemu:///session
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>In both cases, if everything’s working a <code>virsh</code> session should open.</p>

<h1 id="creating-and-managing-virtual-machines">Creating and managing virtual machines</h1>

<h2 id="disk-image-creation-using-the-command-line">Disk image creation using the command line</h2>

<p>Creating a disk for our virtual machine can be achieved both using <code>qemu-img</code> (command-line style)
or the <em>Virtual Machine Manager</em> (GUI style) while creating a new VM, as described <a href="#vm-creation-disk-image-vmm">a few sections
later in this post</a>.</p>

<p>Altough various image formats are supported by QEMU, I’ll be using <strong>qcow2</strong> (QEMU Copy-On-Write 2)
because it seems to be QEMU’s favourite image format and it has a few usefull features, like
compression and snapshots. <sup id="fnref:qemu-qcow2-favourite-features" role="doc-noteref"><a href="#fn:qemu-qcow2-favourite-features" class="footnote" rel="footnote">1</a></sup>
Another interesting image format is <strong>raw</strong>, the default file format, which takes advantage of
holes support in the filesystem. <sup id="fnref:qemu-raw-man" role="doc-noteref"><a href="#fn:qemu-raw-man" class="footnote" rel="footnote">2</a></sup></p>

<p>There’re two basic alternatives for image allocation: using <em>preallocated disk space</em>, which means
that the image file will reserve for itself all the disk space we tell it to, or using a 
<em>dinamically allocated disk space</em>, that is, the image file size grows on-demand (like the default
VirtualBox option for <abbr title="VirtualBox Disk Image">VDI</abbr>).</p>

<p>To keep things organized, I find useful creating a folder exclusively for disk images and another
one for ISO files as this will simplify the machines creation and maintenance later.</p>

<h3 id="fixed-size-disk-image">Fixed size disk image</h3>

<p>Using qcow2 file format, we should run the following command:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span>qemu-img create <span class="nt">-f</span> qcow2 &lt;image-name&gt; &lt;image-size&gt;
</pre></td>
</tr></tbody></table></code></pre></div></div>

<ul>
  <li>
<code>-f</code>: Sets the file type. In this case is qcow2.</li>
  <li>
<code>&lt;image-name&gt;</code>: Filename for the image file.</li>
  <li>
<code>&lt;image-size&gt;</code>: Disk image size in bytes. Optional suffixes <strong>k</strong> or <strong>K</strong> (kilobyte, 1024),
<strong>M</strong> (megabyte, 1024k), <strong>G</strong> (gigabyte, 1024M) and <strong>T</strong> (terabyte, 1024G) are supported. <strong>b</strong>
is ignored. <sup id="fnref:image-size-source" role="doc-noteref"><a href="#fn:image-size-source" class="footnote" rel="footnote">3</a></sup>
</li>
</ul>

<h3 id="dynamically-allocated-disk-image">Dynamically allocated disk image</h3>

<p>The creation of a dynamically allocated disk images is accomplished by running</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]$</span><span class="w"> </span>qemu-img create <span class="nt">-f</span> qcow2 <span class="nt">-o</span> <span class="nv">preallocation</span><span class="o">=</span>off &lt;image-name&gt; &lt;image-size&gt;
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Which is almost the same command used for <a href="#fixed-size-disk-image"><em>fixed size disk images</em></a>, with
the addition of the <code>preallocation</code> option.</p>

<blockquote>
  <p><strong>Note:</strong> Options are set using the <code>-o</code> flag.</p>
</blockquote>

<p>In the <a href="https://linux.die.net/man/1/qemu-img" title="qemu-img(1) - Linux man page">qemu-img(1) man page</a> there’re two definitions of what the <code>preallocation</code>
options actually does.</p>

<p>For <strong>qcow2</strong> it is defined as:</p>

<blockquote>
  <p><strong>preallocation</strong></p>

  <p>Preallocation  mode  (allowed  values:  <strong>off</strong>, <strong>metadata</strong>, <strong>falloc</strong>, <strong>full</strong>). An image
with preallocated metadata is initially  larger but  can improve performance when the image needs
to grow. <strong>falloc</strong> and <strong>full</strong> preallocations are like the same  options of raw format, but sets
up metadata also.</p>
</blockquote>

<p>And for <strong>raw</strong>:</p>

<blockquote>
  <p><strong>preallocation</strong></p>

  <p>Preallocation mode (allowed values: <strong>off</strong>, <strong>falloc</strong>, <strong>full</strong>). <strong>falloc</strong> mode
preallocates space for image by calling <strong>posix_fallocate()</strong>. <strong>full</strong> mode preallocates space for
image by writing data to underlying storage. This data may or may not be zero, depending on the
storage location.</p>
</blockquote>

<h2 id="setting-up-the-virtual-machine-using-virtual-machine-manager">Setting up the virtual machine using <em>Virtual Machine Manager</em>
</h2>

<p>The most common way to setup virtual machines is through pure libvirt, using the command line and
manually editing configuration files.</p>

<p>Altough I feel really comfortable doing it that way, this time I’ll comment on how to do it using a
GUI interface, <em>Virtual Machine Manager</em>.</p>

<h3 id="establishing-a-connection">Establishing a connection</h3>

<p>First, one should add a <em>Connection</em> (<em>File -&gt; Add Connection</em>) between libvirt and the QEMU/KVM
hypervisor (with URI <code>qemu:///system</code>).</p>

<h3 id="configuring-the-disk-image">Configuring the disk image</h3>

<p>We’ll now see a section called QEMU/KVM in the VMM. Right click it, select <em>Details</em> and go to the
<em>Storage</em> tab.</p>

<p>Once there, you probably want to disable the default storage path, which is
<code>/var/lib/libvirt/images</code>, as <code>/var</code> is usually a separated partition with limited disk space.
<sup id="fnref:var-partition" role="doc-noteref"><a href="#fn:var-partition" class="footnote" rel="footnote">4</a></sup> To do this, stop the pool using the <em>Stop pool</em> button on the bottom left corner
and then remove it (or rename it to something different. It’ll be perfectly fine as long as it’s
different than ‘default’).</p>

<p>Let’s now add two new storage pools, using the <em>Add pool</em> button on the bottom left corner of the
window. The first one will be called ‘iso’, and point to a folder with all our ISO files for the
virtual machines; the second will point to our disks folder and will be called ‘default’.</p>

<p>Apply all changes, and close the window.</p>

<h3 id="creating-a-virtual-machine">Creating a virtual machine</h3>

<p>Once in VMM, there’s a big plus ( + ) button on the top left corner which reads <em>Create a new
virtual machine</em> (another way is <em>File -&gt; New Virtual Machine</em>).</p>

<p>There’re a few options in the <em>New VM</em> window, which has just appeared, we’ll pick <em>Local Install
Media (ISO image or CDROM)</em>. One step forward, and we can browse our storage pools and pick the
desired ISO image. The operating system should be autodetected by virt-manager.</p>

<blockquote>
  <p>In case the ISO image file doesn’t appear in our ‘iso’ pool, there’s a refresh button just above
the list of files.</p>
</blockquote>

<h4 id="vm-creation-disk-image-vmm">Disk image</h4>

<p>When we have reached the step that asks us about the disk image for the virtual machine, I prefer
doing it by picking the custom storage option and manually selecting an image that its already
created, altough creating a new one through VMM in a storage pool (different than the one with ISO
images) is a perfectly good option. When using the GUI option, checking <em>Allocate entire volume
now</em> when adding a new storage volume will have the same effect as setting the <code>preallocation</code>
option when using the command line.</p>

<blockquote>
  <p>One thing that should be noted is that image files created by virt-manager are owned by root and
have rw permissions <em>only</em> for the owner. When this is not the desired behaviour, creating the
image using the command line and ‘chowning’ it to the desired user/group can end up being more
simple.</p>
</blockquote>

<h4 id="final-step-in-the-wizard">Final step in the wizard</h4>

<p>Finally, we should give a name our virtual machine. Its name must be unique for migration purposes,
cannot consists only of numbers, and it can contain letters, numbers, periods (.), underscores (_),
and hyphens (-).</p>

<p><strong>Before clicking on <em>Finish</em></strong>, check the <em>Customize configuration before install</em> option and
verify that ‘Network selection’ is set to <code>Virtual network: 'default': NAT</code> (if it shows as
‘inactive’ check <a href="#start-virt-net-default">Starting Virtual network ‘default’</a> section).</p>

<h4 id="finishing-touches-before-running-for-the-first-time">Finishing touches before running for the first time</h4>

<p>A new window should be opened now showing us the VM details.</p>

<p>In the <em>Overview</em> section, look for <em>Hypervisor Details</em> and pick <code>UEFI x86_64</code> as the firmware 
(the one that doesn’t say <code>secboot.fd</code> at the end of its name). Apply the changes.</p>

<p>Click <em>Begin installation</em> on the top left corner and the installation media will be booted.</p>

<h2 id="network-connection">Network connection</h2>

<p>As far as I know, the default <abbr title="Network Interface Controller">NIC</abbr>, <code>Virtual network 'default': Nat</code> using <code>virtio</code> as device model
works out of the box for internet connection and SSH access from the host machine.</p>

<h3 id="start-virt-net-default">Starting virtual network: ‘default’</h3>

<p>To manually start the default network, the following command should be run:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]#</span><span class="w"> </span>virsh net-start default
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>If the desired behaviour is to autostart it on boot time, run</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-line-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="gp">]#</span><span class="w"> </span>virsh net-autostart default
</pre></td>
</tr></tbody></table></code></pre></div></div>

<h1 id="sources">Sources and useful links</h1>

<ul>
  <li>
    <p><a href="https://wiki.archlinux.org/title/QEMU" title="Qemu">ArchWiki: QEMU</a></p>
  </li>
  <li>
    <p><a href="https://wiki.archlinux.org/title/KVM" title="KVM">ArchWiki: KVM</a></p>
  </li>
  <li>
    <p><a href="https://wiki.archlinux.org/title/libvirt" title="libvirt">ArchWiki: libvirt</a></p>
  </li>
  <li>
    <p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-creating_guests_with_virt_manager" title="Creating Guests with virt-manager">Red Hat Customer Portal: Creating Guests with virt-manager</a></p>
  </li>
  <li>
    <p><a href="https://linux.die.net/man/1/qemu-img" title="qemu-img(1) - Linux man page">Linux man page: qemu-img(1)</a></p>
  </li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:qemu-qcow2-favourite-features" role="doc-endnote">

      <p>From <a href="https://linux.die.net/man/1/qemu-img" title="qemu-img(1) - Linux man page">qemu-img(1) manual</a>:</p>
      <blockquote>
        <p><strong>qcow2</strong></p>

        <p>QEMU  image  format, the most versatile format. Use it to have smaller images (useful if
your filesystem does not supports holes, for example on  Windows), optional AES encryption,
zlib based compression and support of multiple VM snapshots.</p>
      </blockquote>
      <p><a href="#fnref:qemu-qcow2-favourite-features" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:qemu-raw-man" role="doc-endnote">

      <p>From <a href="https://linux.die.net/man/1/qemu-img" title="qemu-img(1) - Linux man page">qemu-img(1) manual</a>:</p>
      <blockquote>
        <p><strong>raw</strong></p>

        <p>Raw disk image format (default). This format has the advantage of being simple and easily
exportable to all other emulators. If your file system supports holes (for example in ext2 or
ext3 on Linux or NTFS on Windows), then only the written sectors will reserve space. Use
<code>qemu-img info</code> to know the real size used by the image or <code>ls -ls</code> on Unix/Linux.</p>
      </blockquote>
      <p><a href="#fnref:qemu-raw-man" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:image-size-source" role="doc-endnote">

      <p>From <a href="https://linux.die.net/man/1/qemu-img" title="qemu-img(1) - Linux man page">qemu-img(1) manual</a>. <a href="#fnref:image-size-source" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:var-partition" role="doc-endnote">

      <p>Most distributions GUI installers give the option (and incentivize their users) to put <code>home</code>
in a separated partition from root. That limits <code>var</code> disk space by itself.</p>

      <p>It’s also an option to have <code>var</code> in a completely separated partition as it has the system
logs by default. <a href="#fnref:var-partition" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

  </div>
</article>
</div>
        </div>

        <div class="flex-separator"></div>
        


<footer class="site-footer">
  <div class="site-footer--container">
    <p>
      Created by Martín E. Zahnd 
      <i class="far fa-copyright"></i> 
      2022
    </p>
  </div>
</footer>
    </div>
  </body>
</html>
